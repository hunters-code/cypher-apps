# Cypher Wallet - Frontend Development Rules

## Project Overview
You are working on Cypher, a non-custodial crypto wallet that prioritizes privacy through Stealth Address technology on Base L2. The project uses Next.js, React, TypeScript, Privy.io for authentication, and shadcn/ui for components.

## Tech Stack
- **Framework**: Next.js 14+ (App Router)
- **Language**: TypeScript (strict mode)
- **Styling**: Tailwind CSS
- **UI Components**: shadcn/ui
- **Blockchain**: Wagmi, Viem, Ethers.js
- **Authentication**: Privy.io
- **State Management**: React hooks, Context API
- **Network**: Base L2 (Chain ID: 8453)

## Brand Guidelines

### Color Palette
- **Primary Brand Color**: `#0052FF` (Cypher Blue)
- **Color Tokens**:
  ```css
  --primary: 217 100% 50% /* #0052FF */
  --primary-foreground: 0 0% 100%
  --secondary: 217 91% 60%
  --accent: 217 100% 45%
  --destructive: 0 84% 60%
  --muted: 217 30% 96%
  --background: 0 0% 100%
  --foreground: 222 47% 11%
  ```

### Dark Mode Colors
```css
--primary: 217 100% 50%
--primary-foreground: 0 0% 100%
--background: 222 47% 11%
--foreground: 213 27% 84%
--card: 217 33% 17%
--card-foreground: 213 27% 84%
--muted: 217 33% 17%
--muted-foreground: 215 20% 65%
```

## Code Style & Best Practices

### ESLint Configuration
```json
{
  "extends": [
    "next/core-web-vitals",
    "plugin:@typescript-eslint/recommended",
    "plugin:react-hooks/recommended",
    "prettier"
  ],
  "plugins": ["import"],
  "rules": {
    "@typescript-eslint/no-explicit-any": "error",
    "@typescript-eslint/no-unused-vars": "error",
    "react-hooks/rules-of-hooks": "error",
    "react-hooks/exhaustive-deps": "warn",
    "no-console": ["warn", { "allow": ["warn", "error"] }],
    "prefer-const": "error",
    "no-var": "error",
    "import/order": [
      "error",
      {
        "groups": [
          "builtin",
          "external",
          "internal",
          ["parent", "sibling"],
          "index",
          "type"
        ],
        "pathGroups": [
          {
            "pattern": "react",
            "group": "external",
            "position": "before"
          },
          {
            "pattern": "next/**",
            "group": "external",
            "position": "before"
          },
          {
            "pattern": "@/**",
            "group": "internal",
            "position": "after"
          }
        ],
        "pathGroupsExcludedImportTypes": ["react", "next"],
        "newlines-between": "always",
        "alphabetize": {
          "order": "asc",
          "caseInsensitive": true
        }
      }
    ],
    "import/no-duplicates": "error",
    "import/no-unresolved": "off"
  }
}
```

### Import Order Rules
**Always follow this import order:**

1. **React and Next.js** (external, first)
2. **Other external packages** (alphabetically)
3. **Internal absolute imports** (`@/...`) (alphabetically)
4. **Relative imports** (`./...`, `../...`) (alphabetically)
5. **Type-only imports** (use `import type`)

**Example:**
```typescript
// ✅ GOOD - Correct import order
'use client';

import { useState, useEffect } from 'react';
import { useRouter } from 'next/navigation';
import { usePrivy } from '@privy-io/react-auth';
import { ethers } from 'ethers';

import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { formatCurrency } from '@/lib/utils/format';
import { useWallet } from '@/hooks/useWallet';

import { TransactionCard } from './TransactionCard';
import { TransactionList } from './TransactionList';

import type { Transaction } from '@/types/transaction';

// ❌ BAD - Incorrect import order
import { Button } from '@/components/ui/button';
import { useState } from 'react';
import { TransactionCard } from './TransactionCard';
import { useRouter } from 'next/navigation';
```

**Rules:**
- Separate groups with blank lines
- Alphabetize imports within each group
- Use `import type` for type-only imports
- React and Next.js imports should come first
- Internal imports (`@/...`) come after external packages
- Relative imports come last

### TypeScript Rules
- **Always use strict TypeScript**
- **No `any` types** - use `unknown` and type guards instead
- **Prefer interfaces over types** for object shapes
- **Use type inference** where obvious
- **Define explicit return types** for public functions
- **Use discriminated unions** for transaction types

Example:
```typescript
// ✅ GOOD
interface TransactionBase {
  id: string;
  hash: string;
  timestamp: number;
  status: 'PENDING' | 'CONFIRMED' | 'FAILED';
}

interface SendTransaction extends TransactionBase {
  type: 'SEND';
  recipientUsername: string;
  amount: string;
}

interface ReceiveTransaction extends TransactionBase {
  type: 'RECEIVE';
  senderUsername: string;
  amount: string;
  isPrivate: boolean;
}

type Transaction = SendTransaction | ReceiveTransaction;

// ❌ BAD
type Transaction = {
  type: string;
  data: any;
};
```

### React Component Structure
```typescript
'use client'; // Only when needed (client components)

import { useState, useEffect } from 'react';
import { usePrivy } from '@privy-io/react-auth';

// 1. Types/Interfaces
interface ComponentProps {
  title: string;
  onSubmit: (data: FormData) => Promise<void>;
}

// 2. Component
export function Component({ title, onSubmit }: ComponentProps) {
  // 2a. Hooks (in order: context, state, effects)
  const { user } = usePrivy();
  const [isLoading, setIsLoading] = useState(false);
  
  useEffect(() => {
    // Effect logic
  }, []);
  
  // 2b. Handlers
  const handleSubmit = async () => {
    setIsLoading(true);
    try {
      await onSubmit(formData);
    } catch (error) {
      console.error('Submit failed:', error);
    } finally {
      setIsLoading(false);
    }
  };
  
  // 2c. Render
  return (
    <div className="space-y-4">
      {/* JSX */}
    </div>
  );
}
```

## Tailwind CSS Guidelines

### Class Ordering
Follow this order for consistency:
1. Layout (display, position, top, right, etc.)
2. Box model (width, height, margin, padding)
3. Typography (font, text)
4. Visual (background, border, shadow)
5. Misc (cursor, transition, animation)

Example:
```tsx
<div className="
  flex flex-col items-center justify-between
  w-full max-w-md mx-auto p-6
  text-lg font-semibold text-foreground
  bg-card border border-border rounded-xl shadow-lg
  transition-all duration-200 hover:shadow-xl
">
```

### Responsive Design
- **Mobile-first approach** - base styles for mobile, then use `md:`, `lg:` for larger screens
- **Breakpoints**: `sm: 640px`, `md: 768px`, `lg: 1024px`, `xl: 1280px`

```tsx
<div className="
  grid grid-cols-1 gap-4
  md:grid-cols-2 md:gap-6
  lg:grid-cols-3 lg:gap-8
">
```

### Common Patterns
```tsx
// Card Container
<div className="bg-card border border-border rounded-xl p-6 shadow-sm">

// Button Primary
<button className="
  w-full px-4 py-3
  bg-primary text-primary-foreground
  font-semibold rounded-lg
  hover:bg-primary/90
  disabled:opacity-50 disabled:cursor-not-allowed
  transition-colors duration-200
">

// Input Field
<input className="
  w-full px-4 py-3
  bg-background border border-input
  rounded-lg
  text-foreground placeholder:text-muted-foreground
  focus:outline-none focus:ring-2 focus:ring-primary
  transition-all duration-200
" />

// Text Styles
<h1 className="text-4xl font-bold text-foreground">
<h2 className="text-3xl font-semibold text-foreground">
<p className="text-base text-muted-foreground">
```

## shadcn/ui Component Usage

### Installation & Setup
```bash
npx shadcn-ui@latest add button input card dialog alert
```

### Always Use shadcn/ui Components
**DO NOT create custom components** for these common UI elements:
- Buttons → `<Button>`
- Inputs → `<Input>`
- Cards → `<Card>`
- Modals → `<Dialog>`
- Dropdowns → `<Select>`
- Alerts → `<Alert>`
- Toasts → `<Toast>`
- Loading → `<Skeleton>`

### Component Customization
Extend shadcn components with Tailwind classes:

```tsx
import { Button } from '@/components/ui/button';
import { Card, CardHeader, CardTitle, CardContent } from '@/components/ui/card';

// ✅ GOOD - Extending with Tailwind
<Button className="w-full bg-primary hover:bg-primary/90">
  Send Transaction
</Button>

<Card className="bg-gradient-to-br from-primary/10 to-primary/5">
  <CardHeader>
    <CardTitle>Balance</CardTitle>
  </CardHeader>
  <CardContent>
    <p className="text-3xl font-bold">1.5 ETH</p>
  </CardContent>
</Card>

// ❌ BAD - Creating custom button component
function CustomButton({ children }) {
  return <button className="...">{children}</button>;
}
```

### shadcn Form Pattern
```tsx
'use client';

import { useState } from 'react';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Alert, AlertDescription } from '@/components/ui/alert';

export function TransferForm() {
  const [username, setUsername] = useState('');
  const [amount, setAmount] = useState('');
  const [error, setError] = useState('');

  return (
    <div className="space-y-4">
      <div className="space-y-2">
        <Label htmlFor="username">Recipient Username</Label>
        <Input
          id="username"
          placeholder="@nashirjamali"
          value={username}
          onChange={(e) => setUsername(e.target.value)}
        />
      </div>

      <div className="space-y-2">
        <Label htmlFor="amount">Amount</Label>
        <Input
          id="amount"
          type="number"
          placeholder="1.5"
          value={amount}
          onChange={(e) => setAmount(e.target.value)}
        />
      </div>

      {error && (
        <Alert variant="destructive">
          <AlertDescription>{error}</AlertDescription>
        </Alert>
      )}

      <Button className="w-full" onClick={handleSubmit}>
        Continue
      </Button>
    </div>
  );
}
```

## Project Structure

```
src/
├── app/
│   ├── (auth)/
│   │   ├── login/
│   │   └── onboarding/
│   ├── dashboard/
│   │   ├── page.tsx
│   │   ├── layout.tsx
│   │   └── components/
│   ├── transfer/
│   │   └── page.tsx
│   ├── history/
│   │   └── page.tsx
│   └── layout.tsx
├── components/
│   ├── ui/                    # shadcn components
│   ├── wallet/                # Wallet-specific components
│   ├── transaction/           # Transaction components
│   └── layout/                # Layout components
├── lib/
│   ├── blockchain/
│   │   ├── stealth.ts         # Stealth address cryptography
│   │   ├── registry.ts        # Smart contract interactions
│   │   └── scanner.ts         # Event scanning
│   ├── storage/
│   │   ├── keys.ts            # Secure key storage
│   │   └── transactions.ts    # Transaction storage
│   ├── utils/
│   │   ├── format.ts          # Formatting utilities
│   │   └── validation.ts      # Input validation
│   └── constants.ts
├── hooks/
│   ├── useWallet.ts
│   ├── useTransaction.ts
│   └── useStealth.ts
├── providers/
│   └── PrivyProvider.tsx
└── types/
    ├── transaction.ts
    ├── wallet.ts
    └── stealth.ts
```

## File Naming Conventions
- **Components**: PascalCase - `TransactionCard.tsx`
- **Utilities**: camelCase - `formatAddress.ts`
- **Hooks**: camelCase with 'use' prefix - `useWallet.ts`
- **Types**: PascalCase - `Transaction.ts`
- **Constants**: UPPER_SNAKE_CASE - `REGISTRY_ADDRESS`

## Blockchain Integration Best Practices

### Wagmi Hooks
```typescript
import { useAccount, useBalance, useWriteContract } from 'wagmi';

export function WalletBalance() {
  const { address } = useAccount();
  const { data: balance, isLoading } = useBalance({
    address,
  });

  if (isLoading) return <Skeleton className="h-8 w-32" />;

  return (
    <div className="text-2xl font-bold">
      {balance?.formatted} {balance?.symbol}
    </div>
  );
}
```

### Error Handling for Blockchain Calls
```typescript
async function sendTransaction() {
  try {
    setIsLoading(true);
    setError('');

    const tx = await writeContract({
      address: REGISTRY_ADDRESS,
      abi: REGISTRY_ABI,
      functionName: 'registerID',
      args: [username, viewingKey],
    });

    await tx.wait();
    
    // Success handling
  } catch (error) {
    if (error instanceof Error) {
      if (error.message.includes('user rejected')) {
        setError('Transaction cancelled');
      } else if (error.message.includes('insufficient funds')) {
        setError('Insufficient balance for gas');
      } else {
        setError('Transaction failed. Please try again.');
      }
    }
    console.error('Transaction error:', error);
  } finally {
    setIsLoading(false);
  }
}
```

### Stealth Address Implementation
```typescript
import { ethers } from 'ethers';

interface StealthKeys {
  viewingKey: string;
  viewingKeyPrivate: string;
  spendingKey: string;
  spendingKeyPrivate: string;
}

export async function generateViewingKey(
  walletAddress: string
): Promise<StealthKeys> {
  // Generate viewing key pair
  const viewingKeyPrivate = ethers.Wallet.createRandom().privateKey;
  const viewingKeyPublic = ethers.utils.computePublicKey(
    viewingKeyPrivate,
    true
  );

  // Generate spending key pair
  const spendingKeyPrivate = ethers.Wallet.createRandom().privateKey;
  const spendingKeyPublic = ethers.utils.computePublicKey(
    spendingKeyPrivate,
    true
  );

  return {
    viewingKey: viewingKeyPublic,
    viewingKeyPrivate,
    spendingKey: spendingKeyPublic,
    spendingKeyPrivate,
  };
}

export function generateStealthAddress(
  recipientViewingKey: string,
  ephemeralPrivateKey?: string
): {
  stealthAddress: string;
  ephemeralPublicKey: string;
} {
  // Generate ephemeral key pair
  const ephemeralKey =
    ephemeralPrivateKey || ethers.Wallet.createRandom().privateKey;
  const ephemeralPublic = ethers.utils.computePublicKey(ephemeralKey, true);

  // Compute shared secret using ECDH
  const sharedSecret = ethers.utils.computeAddress(
    ethers.utils.keccak256(
      ethers.utils.concat([
        ethers.utils.arrayify(ephemeralKey),
        ethers.utils.arrayify(recipientViewingKey),
      ])
    )
  );

  // Generate stealth address
  const stealthAddress = ethers.utils.getAddress(sharedSecret);

  return {
    stealthAddress,
    ephemeralPublicKey: ephemeralPublic,
  };
}
```

## Performance Optimization

### Code Splitting
```typescript
// Use dynamic imports for heavy components
import dynamic from 'next/dynamic';

const TransactionHistory = dynamic(
  () => import('@/components/transaction/TransactionHistory'),
  {
    loading: () => <Skeleton className="h-96 w-full" />,
    ssr: false,
  }
);
```

### Memoization
```typescript
import { useMemo, useCallback } from 'react';

export function TransactionList({ transactions }: Props) {
  // Memoize expensive calculations
  const sortedTransactions = useMemo(() => {
    return [...transactions].sort((a, b) => b.timestamp - a.timestamp);
  }, [transactions]);

  // Memoize callbacks
  const handleFilter = useCallback((type: TransactionType) => {
    setFilter(type);
  }, []);

  return (
    <div>
      {sortedTransactions.map((tx) => (
        <TransactionCard key={tx.id} transaction={tx} />
      ))}
    </div>
  );
}
```

### Virtual Scrolling for Long Lists
```typescript
import { useVirtualizer } from '@tanstack/react-virtual';

export function TransactionHistory({ transactions }: Props) {
  const parentRef = useRef<HTMLDivElement>(null);

  const virtualizer = useVirtualizer({
    count: transactions.length,
    getScrollElement: () => parentRef.current,
    estimateSize: () => 80,
  });

  return (
    <div ref={parentRef} className="h-96 overflow-auto">
      <div
        style={{
          height: `${virtualizer.getTotalSize()}px`,
          position: 'relative',
        }}
      >
        {virtualizer.getVirtualItems().map((virtualRow) => (
          <div
            key={virtualRow.index}
            style={{
              position: 'absolute',
              top: 0,
              left: 0,
              width: '100%',
              transform: `translateY(${virtualRow.start}px)`,
            }}
          >
            <TransactionCard transaction={transactions[virtualRow.index]} />
          </div>
        ))}
      </div>
    </div>
  );
}
```

## State Management Patterns

### Local Storage Utilities
```typescript
export function saveToLocalStorage<T>(key: string, data: T): void {
  try {
    const serialized = JSON.stringify(data);
    localStorage.setItem(key, serialized);
  } catch (error) {
    console.error('Failed to save to localStorage:', error);
  }
}

export function loadFromLocalStorage<T>(key: string): T | null {
  try {
    const serialized = localStorage.getItem(key);
    if (!serialized) return null;
    return JSON.parse(serialized) as T;
  } catch (error) {
    console.error('Failed to load from localStorage:', error);
    return null;
  }
}
```

### Context Pattern for Global State
```typescript
'use client';

import { createContext, useContext, useState, ReactNode } from 'react';

interface WalletContextType {
  balance: string;
  address: string | null;
  isConnected: boolean;
  connect: () => Promise<void>;
  disconnect: () => void;
}

const WalletContext = createContext<WalletContextType | undefined>(undefined);

export function WalletProvider({ children }: { children: ReactNode }) {
  const [balance, setBalance] = useState('0');
  const [address, setAddress] = useState<string | null>(null);
  const [isConnected, setIsConnected] = useState(false);

  const connect = async () => {
    // Connection logic
  };

  const disconnect = () => {
    // Disconnect logic
  };

  return (
    <WalletContext.Provider
      value={{ balance, address, isConnected, connect, disconnect }}
    >
      {children}
    </WalletContext.Provider>
  );
}

export function useWallet() {
  const context = useContext(WalletContext);
  if (!context) {
    throw new Error('useWallet must be used within WalletProvider');
  }
  return context;
}
```

## Security Best Practices

### Never Expose Private Keys
```typescript
// ✅ GOOD - Keys stored securely
async function saveKeysSecurely(keys: StealthKeys): Promise<void> {
  const encrypted = await encryptKeys(keys);
  localStorage.setItem('cypher_keys_encrypted', encrypted);
}

// ❌ BAD - Keys in plain text
localStorage.setItem('keys', JSON.stringify(keys));
```

### Input Validation
```typescript
export function validateUsername(username: string): boolean {
  if (!username.startsWith('@')) return false;
  if (username.length < 4) return false;
  if (!/^@[a-zA-Z0-9_]+$/.test(username)) return false;
  return true;
}

export function validateAmount(amount: string): boolean {
  const parsed = parseFloat(amount);
  if (isNaN(parsed)) return false;
  if (parsed <= 0) return false;
  return true;
}
```

### Rate Limiting for Blockchain Calls
```typescript
import { useCallback, useRef } from 'react';

export function useRateLimitedFunction<T extends (...args: unknown[]) => unknown>(
  fn: T,
  delay: number
) {
  const timeoutRef = useRef<NodeJS.Timeout>();

  return useCallback(
    (...args: Parameters<T>) => {
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
      }

      timeoutRef.current = setTimeout(() => {
        fn(...args);
      }, delay);
    },
    [fn, delay]
  );
}
```

## Testing Guidelines

### Component Testing Template
```typescript
import { render, screen, fireEvent } from '@testing-library/react';
import { TransferForm } from './TransferForm';

describe('TransferForm', () => {
  it('validates username format', async () => {
    render(<TransferForm />);
    
    const input = screen.getByPlaceholderText('@username');
    fireEvent.change(input, { target: { value: 'invalid' } });
    
    const error = await screen.findByText(/must start with @/i);
    expect(error).toBeInTheDocument();
  });

  it('submits valid transfer', async () => {
    const onSubmit = jest.fn();
    render(<TransferForm onSubmit={onSubmit} />);
    
    const usernameInput = screen.getByPlaceholderText('@username');
    const amountInput = screen.getByPlaceholderText('Amount');
    
    fireEvent.change(usernameInput, { target: { value: '@alice' } });
    fireEvent.change(amountInput, { target: { value: '1.5' } });
    
    const submitButton = screen.getByText('Send');
    fireEvent.click(submitButton);
    
    expect(onSubmit).toHaveBeenCalledWith({
      username: '@alice',
      amount: '1.5',
    });
  });
});
```

## Accessibility Standards

### ARIA Labels
```tsx
<button
  aria-label="Send transaction to @nashirjamali"
  className="..."
>
  Send
</button>

<input
  aria-label="Recipient username"
  aria-describedby="username-help"
  aria-invalid={!!error}
  aria-required="true"
/>
```

### Keyboard Navigation
```tsx
<div
  role="button"
  tabIndex={0}
  onKeyDown={(e) => {
    if (e.key === 'Enter' || e.key === ' ') {
      handleClick();
    }
  }}
  onClick={handleClick}
>
```

## Loading States

### Skeleton Loaders
```tsx
import { Skeleton } from '@/components/ui/skeleton';

export function TransactionSkeleton() {
  return (
    <div className="space-y-4">
      <Skeleton className="h-12 w-full" />
      <Skeleton className="h-12 w-full" />
      <Skeleton className="h-12 w-full" />
    </div>
  );
}
```

### Loading Indicators
```tsx
import { Loader2 } from 'lucide-react';
import { Button } from '@/components/ui/button';

<Button disabled={isLoading}>
  {isLoading ? (
    <>
      <Loader2 className="mr-2 h-4 w-4 animate-spin" />
      Processing...
    </>
  ) : (
    'Send Transaction'
  )}
</Button>
```

## Environment Variables

```env
# .env.local

# Privy
NEXT_PUBLIC_PRIVY_APP_ID=your_privy_app_id

# Smart Contracts
NEXT_PUBLIC_REGISTRY_ADDRESS=0x...
NEXT_PUBLIC_ANNOUNCEMENT_ADDRESS=0x...

# Base L2
NEXT_PUBLIC_BASE_RPC_URL=https://mainnet.base.org
NEXT_PUBLIC_CHAIN_ID=8453

# API Keys
NEXT_PUBLIC_ALCHEMY_API_KEY=your_alchemy_key
```

## Git Commit Convention

```
feat: add stealth address generation
fix: resolve transaction scanning bug
style: update button colors to match brand
refactor: improve transaction storage logic
test: add unit tests for username validation
docs: update README with setup instructions
chore: update dependencies
```

## Common Patterns to Follow

### Loading State Pattern
```tsx
const [data, setData] = useState<Data | null>(null);
const [isLoading, setIsLoading] = useState(true);
const [error, setError] = useState<string | null>(null);

useEffect(() => {
  async function fetchData() {
    try {
      setIsLoading(true);
      setError(null);
      const result = await api.getData();
      setData(result);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'An error occurred');
    } finally {
      setIsLoading(false);
    }
  }
  
  fetchData();
}, []);

if (isLoading) return <Skeleton />;
if (error) return <Alert variant="destructive">{error}</Alert>;
if (!data) return <p>No data available</p>;

return <DataDisplay data={data} />;
```

### Form Handling Pattern
```tsx
const [formData, setFormData] = useState({
  username: '',
  amount: '',
});

const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
  const { name, value } = e.target;
  setFormData(prev => ({
    ...prev,
    [name]: value,
  }));
};

const handleSubmit = async (e: React.FormEvent) => {
  e.preventDefault();
  // Validation
  if (!validateUsername(formData.username)) {
    setError('Invalid username');
    return;
  }
  // Submit logic
};
```

## Performance Checklist
- [ ] Use Next.js Image component for images
- [ ] Implement code splitting for heavy components
- [ ] Add React.memo for expensive components
- [ ] Use useMemo for expensive calculations
- [ ] Use useCallback for callback functions passed to children
- [ ] Implement virtual scrolling for long lists
- [ ] Add proper loading states
- [ ] Optimize bundle size with dynamic imports
- [ ] Use Suspense boundaries appropriately

## Final Reminders
1. **Always use shadcn/ui components** - don't reinvent the wheel
2. **Primary color is #0052FF** - use it consistently
3. **Mobile-first responsive design** - test on mobile
4. **TypeScript strict mode** - no `any` types
5. **Error handling** - always handle blockchain errors gracefully
6. **Loading states** - show feedback for async operations
7. **Accessibility** - use proper ARIA labels
8. **Security** - never expose private keys
9. **Testing** - write tests for critical paths
10. **Performance** - optimize for fast load times
